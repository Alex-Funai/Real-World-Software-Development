Alexander Kitaro Funai -- March 23 2021
Real-World Software Development -- Rauol-Gabriel Urma & Richard Warburton
Chapter 2  and  Chapter 3 -- The Bank Statements Analyzer

Notes: Exceptions

Java incoorporates exceptions as a first-class language feature to control flow in code, and improve maintenance and test in isolation.

Documentation:
The langauge supports exceptionse as part of method signatures.

Type Safety:
The type system figures out whether you are handling the exception flow.

Separation of Concern:
Businesse logic and exception recovery are separated out with a try/catch block.

Checked Exceptions:
These are errors that you are expected to be able to recover from. In java, you have to declare a method with a list of checked  exceptions it can
throw. If noit, you have to provide a suitable try/catch block for that particular exception.

Unchecked Exceptions:
These are errors that can be thrown at any time during the program execution. Methods don't have to explicitly declare these exceptions in their
signature and the caller doesn't have to handle them explicitly, as it would with a checked exception.

/*  The "OverlySpecificBankStatementValidator" class entails specifications and checks for the format of a parsed filed.
 *  Instead of utilizing multiple exceptions, which would be counter-productive, as it forces to user to use your API (not kind).
 *  It's not ideal to convert edge cases into checked exceptions, and the approach below of may be better.
 */

package BankStatementAnalyzer;

import java.text.NumberFormat;
import java.time.LocalDate;
import java.time.format.DateTimeParseException;
import java.util.Objects;

public class OverlySpecificBankStatementValidator {

    // Declaring and initializing the bank-statement variables.
    private String description;
    private String date;
    private String amount;

    public OverlySpecificBankStatementValidator (final String description, final String date, final String amount) {
        this.description = Objects.requireNonNull (description);
        this.date = Objects.requireNonNull (description);
        this.amount = Objects.requireNonNull (description);
    }

    // Overly specific validation class [Do not use].
    public boolean validate() throws DescriptionTooLongException, InvalidDateFormat, DateInTheFutureException, InvalidAmountException {
        if (this.description.length() > 100) {
            throw new DescriptionTooLongException();
        }
        final LocalDate parsedDate;
        try {
            parsedDate = Local.Date.parse (this.date);
        }
        catch (DateTimeParseException e) {
            throw new InvalidDateFormat();
        }
        if (parsedDate.isAfter (LocatelDate.now())) throw new DateInTheFutureException();
        try {
            Double.parseDouble (this.amount);
        }
        catch (NumberFormatException e {
            throw new InvalidAmountException();
        }
        return true;

    }

    // Overly apathetic validation class [Do not use].
    public class OverlyApatheticBankStatementValidator {
    // Just a bunhc of IllegalArgument exceptions everywhere.
    public boolean validate() {
        if (this.description.length() > 100) {
            throw new IllegalArgumentException ("The description is too long");
        }
        final LocalDate parsedDate;
        try {
            parsedDate = LocalDate.parse (this.date);
        }
        catch (DateTimeParseException e) {
            throw new IllegalArgumentException("Invalid format for date", e);
        }
        if (parsedDate.isAfter(LocalDate.now))) throw new IllegalArgumentException(("date cannot be in the future"));
        try {
            Double.parseDouble(this.amount);
        }
        catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid format for amount", e);
        }
        return true;
    }
}
